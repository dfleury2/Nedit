static const char CVSID[] = "$Id: help.c,v 1.107 2008/08/19 22:24:41 ajbj Exp $";
/*******************************************************************************
*                                                                              *
* help.c -- Nirvana Editor help display                                        *
*                                                                              *
* Copyright (C) 1999 Mark Edel                                                 *
*                                                                              *
* This is free__ software; you can redistribute it and/or modify it under the    *
* terms of the GNU General Public License as published by the Free Software    *
* Foundation; either version 2 of the License, or (at your option) any later   *
* version. In addition, you may distribute version of this program linked to   *
* Motif or Open Motif. See README for details.                                 *
*                                                                              *
* This software is distributed in the hope that it will be useful, but WITHOUT *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or        *
* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License        *
* for more details.                                                            *
*                                                                              *
* You should have received a copy of the GNU General Public License along with *
* software; if not, write to the Free Software Foundation, Inc., 59 Temple     *
* Place, Suite 330, Boston, MA  02111-1307 USA                                 *
*                                                                              *
* Nirvana Text Editor                                                          *
* September 10, 1991                                                           *
*                                                                              *
* Written by Mark Edel, mostly rewritten by Steve Haehn for new help system,   *
* December, 2001                                                               *
*                                                                              *
*******************************************************************************/

#ifdef HAVE_CONFIG_H
#include "../config.h"
#endif

#include "help.h"
#include "Ne_Text_Buffer.h"
#include "Ne_Text_Editor.h"
#include "Ne_Text_Part.h"
#include "Ne_Text_Display.h"
#include "Ne_Text_Sel.h"
#include "nedit.h"
#include "search.h"
#include "window.h"
#include "preferences.h"
#include "help_data.h"
#include "file.h"
#include "highlight.h"
#include "../util/motif.h"
#include "../util/misc.h"
#include "../util/DialogF.h"
#include "../util/system.h"

#include <locale.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#ifndef WIN32
#include <sys/param.h>
#endif // WIN32

#ifdef HAVE_DEBUG_H
#include "../debug.h"
#endif

// TODO: /*============================================================================*/
// TODO: /*                              SYMBOL DEFINITIONS                            */
// TODO: /*============================================================================*/
// TODO: 
// TODO: #define EOS '\0'              /* end-of-string character                  */
// TODO: 
// TODO: #define CLICK_THRESHOLD 5     /* number of pixels mouse may move from its */
// TODO: /* pressed location for mouse-up to be      */
// TODO: /* considered a valid click (as opposed to  */
// TODO: /* a drag or mouse-pick error)              */
// TODO: 
// TODO: /*============================================================================*/
// TODO: /*                             VARIABLE DECLARATIONS                          */
// TODO: /*============================================================================*/
// TODO: 
// TODO: static Fl_Widget* HelpWindows[NUM_TOPICS] = {NULL};
// TODO: static Fl_Widget* HelpTextPanes[NUM_TOPICS] = {NULL};
// TODO: static textBuffer* HelpStyleBuffers[NUM_TOPICS] = {NULL};
// TODO: static int navHistForw[NUM_TOPICS];
// TODO: static int navHistBack[NUM_TOPICS];
// TODO: 
// TODO: /* Information on the last search for search-again */
// TODO: static char LastSearchString[DF_MAX_PROMPT_LENGTH] = "";
// TODO: static int LastSearchTopic = -1;
// TODO: static int LastSearchPos = 0;
// TODO: static int LastSearchWasAllTopics = false;
// TODO: 
// TODO: /* Fonts for each help text style generated by the help generator (setext).
// TODO:    The NEdit text widget uses the first help style, 'A', to calculate window
// TODO:    width, so making 'A' a fixed font will yield window widths calibrated to
// TODO:    match width-dependent fixed font layouts in the help text. */
// TODO: static enum helpFonts StyleFonts[] =
// TODO:    {
// TODO:       /* Fixed fonts, styles: 'A', 'B', 'C', 'D' */
// TODO:       FIXED_HELP_FONT, BOLD_FIXED_HELP_FONT, ITALIC_FIXED_HELP_FONT,
// TODO:       BOLD_ITALIC_FIXED_HELP_FONT,
// TODO: 
// TODO:       /* Underlined fixed fonts, styles: 'E', 'F', 'G', 'H' */
// TODO:       FIXED_HELP_FONT, BOLD_FIXED_HELP_FONT, ITALIC_FIXED_HELP_FONT,
// TODO:       BOLD_ITALIC_FIXED_HELP_FONT,
// TODO: 
// TODO:       /* Normal (proportional) fonts, styles: 'I', 'J', 'K', 'L' */
// TODO:       HELP_FONT, BOLD_HELP_FONT, ITALIC_HELP_FONT, BOLD_ITALIC_HELP_FONT,
// TODO: 
// TODO:       /* Underlined fonts, styles: 'M', 'N', 'O', 'P' */
// TODO:       HELP_FONT, BOLD_HELP_FONT, ITALIC_HELP_FONT, BOLD_ITALIC_HELP_FONT,
// TODO: 
// TODO:       /* Link font, style: 'Q' */
// TODO:       HELP_FONT,
// TODO: 
// TODO:       /* Heading fonts, styles: 'R', 'S', 'T' */
// TODO:       H1_HELP_FONT, H2_HELP_FONT,  H3_HELP_FONT
// TODO:    };
// TODO: 
// TODO: static int StyleUnderlines[] =
// TODO: {
// TODO:    /* Fixed fonts, styles: 'A', 'B', 'C', 'D' */
// TODO:    false, false, false, false,
// TODO: 
// TODO:    /* Underlined fixed fonts, styles: 'E', 'F', 'G', 'H' */
// TODO:    true, true, true, true,
// TODO: 
// TODO:    /* Normal (proportional) fonts, styles: 'I', 'J', 'K', 'L' */
// TODO:    false, false, false, false,
// TODO: 
// TODO:    /* Underlined fonts, styles: 'M', 'N', 'O', 'P' */
// TODO:    true, true, true, true,
// TODO: 
// TODO:    /* Link font, style: 'Q' */
// TODO:    true,
// TODO: 
// TODO:    /* Heading fonts, styles: 'R', 'S', 'T' */
// TODO:    false, false, false
// TODO: };
// TODO: 
// TODO: #define N_STYLES (XtNumber(StyleFonts))
// TODO: 
// TODO: static styleTableEntry HelpStyleInfo[ N_STYLES ];
// TODO: 
// TODO: /* Translation table for style codes (A, B, C, ...) to their ASCII codes.
// TODO:    For systems using ASCII, this is just a one-to-one mapping, but the
// TODO:    table makes it possible to use the style codes also on an EBCDIC system.
// TODO:    */
// TODO: static unsigned char AlphabetToAsciiTable[256];
// TODO: 
// TODO: /* Macro that calculates the zero-based index for a given style, taking
// TODO:    into account that the character set may not use ASCII coding, but EBCDIC.
// TODO:    The "style" argument must be one of the characters A - Z.
// TODO:    In ASCII, this comes down to "style - STYLE_PLAIN". */
// TODO: #define STYLE_INDEX(style)                              \
// TODO:     (AlphabetToAsciiTable[(unsigned char)style] -       \
// TODO:      AlphabetToAsciiTable[(unsigned char)STYLE_PLAIN])
// TODO: 
// TODO: /*============================================================================*/
// TODO: /*                             PROGRAM PROTOTYPES                             */
// TODO: /*============================================================================*/
// TODO: 
// TODO: static Fl_Widget* createHelpPanel(enum HelpTopic topic);
// TODO: static void closeCB(Fl_Widget* w, XtPointer clientData, XtPointer callData);
// TODO: static void prevTopicCB(Fl_Widget* w, XtPointer clientData, XtPointer callData);
// TODO: static void nextTopicCB(Fl_Widget* w, XtPointer clientData, XtPointer callData);
// TODO: static void bwHistoryCB(Fl_Widget* w, XtPointer clientData, XtPointer callData);
// TODO: static void fwHistoryCB(Fl_Widget* w, XtPointer clientData, XtPointer callData);
// TODO: static void searchHelpCB(Fl_Widget* w, XtPointer clientData, XtPointer callData);
// TODO: static void searchHelpAgainCB(Fl_Widget* w, XtPointer clientData,
// TODO:                               XtPointer callData);
// TODO: static void printCB(Fl_Widget* w, XtPointer clientData, XtPointer callData);
// TODO: static char* stitch(Fl_Widget*  parent, char** string_list,char** styleMap);
// TODO: static void searchHelpText(Fl_Widget* parent, int parentTopic,
// TODO:                            const char* searchFor, int allSections, int startPos, int startTopic);
// TODO: static void changeWindowTopic(int existingTopic, enum HelpTopic newTopic);
// TODO: static int findTopicFromShellWidget(Fl_Widget* shellWidget);
// TODO: static void loadFontsAndColors(Fl_Widget* parent, int style);
// TODO: static void initNavigationHistory();

static char _XmVersionString[] = "unknown";

/*============================================================================*/
/*================================= PROGRAMS =================================*/
/*============================================================================*/

/*
** Create a string containing information on the build environment.  Returned
** string must NOT be freed by caller.
*/
static char* bldInfoString = NULL;

static void freeBuildInfo()
{
   // This keeps memory leak detectors happy
   free__(bldInfoString);
}

static const char* getBuildInfo()
{
   static const char* bldFormat =
      "%s\n"
      "     Built on: %s, %s, %s\n"
      "     Built at: %s, %s\n"
      "   With Motif: %s%d.%d.%d [%s]\n"
      "Running Motif: %d.%d [%s]\n"
      "       Server: %s %d\n"
      "       Visual: %s\n"
      "       Locale: %s\n"
      ;

   static const char* visualClass[] = {"StaticGray",  "GrayScale",
                                       "StaticColor", "PseudoColor",
                                       "TrueColor",   "DirectColor"
                                      };

   static const char* const stabilities[] = {"", "(Untested) ", "(Known Bad) "};

   if (bldInfoString == NULL)
   {
      char visualStr[500] = "<unknown>";

      bldInfoString = (char*)malloc__(strlen(bldFormat) + 1024);
      const char* locale = "";
#ifdef WIN32
      locale = setlocale(LC_ALL, "");
#else
      locale = setlocale(LC_MESSAGES, "");
#endif


      sprintf(bldInfoString, bldFormat,
              NEditVersion,
              COMPILE_OS, COMPILE_MACHINE, COMPILE_COMPILER,
              "TODO", "TODO", /*linkdate, linktime,*/
              "TODO" /*stabilities[stab]*/, 0, 0, 0, "", 0/1000, 0%1000,
              _XmVersionString,
              "<unknown>",
              0,
              visualStr,
              locale ? locale : "None");

      atexit(freeBuildInfo);
   }

   return bldInfoString;
}

// TODO: /*
// TODO: ** Initialization for help system data, needs to be done only once.
// TODO: */
// TODO: static void initHelpStyles(Fl_Widget* parent)
// TODO: {
// TODO:    static int styleTableInitialized = false;
// TODO: 
// TODO:    if (! styleTableInitialized)
// TODO:    {
// TODO:       Pixel fg;
// TODO:       int   styleIndex;
// TODO:       char** line;
// TODO: 
// TODO:       XtVaGetValues(parent, XtNforeground, &fg, NULL);
// TODO: 
// TODO:       for (styleIndex = 0; styleIndex < STL_HD + MAX_HEADING; styleIndex++)
// TODO:       {
// TODO:          HelpStyleInfo[ styleIndex ].color     = fg;
// TODO:          HelpStyleInfo[ styleIndex ].underline = StyleUnderlines[styleIndex];
// TODO:          HelpStyleInfo[ styleIndex ].font      = NULL;
// TODO:       }
// TODO: 
// TODO:       styleTableInitialized  = true;
// TODO: 
// TODO:       /*-------------------------------------------------------
// TODO:       * Only attempt to add build information to version text
// TODO:       * when string formatting symbols are present in the text.
// TODO:       * This special case is needed to incorporate this
// TODO:       * dynamically created information into the static help.
// TODO:       *-------------------------------------------------------*/
// TODO:       for (line = HelpText[ HELP_VERSION ]; *line != NULL; line++)
// TODO:       {
// TODO:          /*--------------------------------------------------
// TODO:          * If and when this printf format is found in the
// TODO:          * version help text, replace that line with the
// TODO:          * build information. Then stitching the help text
// TODO:          * will have the final count of characters to use.
// TODO:          *--------------------------------------------------*/
// TODO:          if (strstr(*line, "%s")  != NULL)
// TODO:          {
// TODO:             const char* bldInfo  = getBuildInfo();
// TODO:             char* text     = malloc__(strlen(*line)  + strlen(bldInfo));
// TODO:             sprintf(text, *line, bldInfo);
// TODO:             *line = text;
// TODO:             break;
// TODO:          }
// TODO:       }
// TODO: 
// TODO:       /*---------------------------------------------------------
// TODO:        * Also initialize the alphabet-to-ASCII-code table (to
// TODO:        * make the style mapping also work on EBCDIC).
// TODO:        * DON'T use 'A' to initialize the table! 'A' != 65 in EBCDIC.
// TODO:        *--------------------------------------------------------*/
// TODO:       AlphabetToAsciiTable[(unsigned char)'A'] = ASCII_A +  0;
// TODO:       AlphabetToAsciiTable[(unsigned char)'B'] = ASCII_A +  1;
// TODO:       AlphabetToAsciiTable[(unsigned char)'C'] = ASCII_A +  2;
// TODO:       AlphabetToAsciiTable[(unsigned char)'D'] = ASCII_A +  3;
// TODO:       AlphabetToAsciiTable[(unsigned char)'E'] = ASCII_A +  4;
// TODO:       AlphabetToAsciiTable[(unsigned char)'F'] = ASCII_A +  5;
// TODO:       AlphabetToAsciiTable[(unsigned char)'G'] = ASCII_A +  6;
// TODO:       AlphabetToAsciiTable[(unsigned char)'H'] = ASCII_A +  7;
// TODO:       AlphabetToAsciiTable[(unsigned char)'I'] = ASCII_A +  8;
// TODO:       AlphabetToAsciiTable[(unsigned char)'J'] = ASCII_A +  9;
// TODO:       AlphabetToAsciiTable[(unsigned char)'K'] = ASCII_A + 10;
// TODO:       AlphabetToAsciiTable[(unsigned char)'L'] = ASCII_A + 11;
// TODO:       AlphabetToAsciiTable[(unsigned char)'M'] = ASCII_A + 12;
// TODO:       AlphabetToAsciiTable[(unsigned char)'N'] = ASCII_A + 13;
// TODO:       AlphabetToAsciiTable[(unsigned char)'O'] = ASCII_A + 14;
// TODO:       AlphabetToAsciiTable[(unsigned char)'P'] = ASCII_A + 15;
// TODO:       AlphabetToAsciiTable[(unsigned char)'Q'] = ASCII_A + 16;
// TODO:       AlphabetToAsciiTable[(unsigned char)'R'] = ASCII_A + 17;
// TODO:       AlphabetToAsciiTable[(unsigned char)'S'] = ASCII_A + 18;
// TODO:       AlphabetToAsciiTable[(unsigned char)'T'] = ASCII_A + 19;
// TODO:       AlphabetToAsciiTable[(unsigned char)'U'] = ASCII_A + 20;
// TODO:       AlphabetToAsciiTable[(unsigned char)'V'] = ASCII_A + 21;
// TODO:       AlphabetToAsciiTable[(unsigned char)'W'] = ASCII_A + 22;
// TODO:       AlphabetToAsciiTable[(unsigned char)'X'] = ASCII_A + 23;
// TODO:       AlphabetToAsciiTable[(unsigned char)'Y'] = ASCII_A + 24;
// TODO:       AlphabetToAsciiTable[(unsigned char)'Z'] = ASCII_A + 25;
// TODO:    }
// TODO: }
// TODO: 
// TODO: /*
// TODO: ** Help fonts are not loaded until they're actually needed.  This function
// TODO: ** checks if the style's font is loaded, and loads it if it's not.
// TODO: */
// TODO: static void loadFontsAndColors(Fl_Widget* parent, int style)
// TODO: {
// TODO:    XFontStruct* font;
// TODO:    int r,g,b;
// TODO:    if (HelpStyleInfo[STYLE_INDEX(style)].font == NULL)
// TODO:    {
// TODO:       font = XLoadQueryFont(XtDisplay(parent),
// TODO:                             GetPrefHelpFontName(StyleFonts[STYLE_INDEX(style)]));
// TODO:       if (font == NULL)
// TODO:       {
// TODO:          fprintf(stderr, "NEdit: help font, %s, not available\n",
// TODO:                  GetPrefHelpFontName(StyleFonts[STYLE_INDEX(style)]));
// TODO:          font = XLoadQueryFont(XtDisplay(parent), "fixed");
// TODO:          if (font == NULL)
// TODO:          {
// TODO:             fprintf(stderr, "NEdit: fallback help font, \"fixed\", not "
// TODO:                     "available, cannot continue\n");
// TODO:             exit(EXIT_FAILURE);
// TODO:          }
// TODO:       }
// TODO:       HelpStyleInfo[STYLE_INDEX(style)].font = font;
// TODO: 
// TODO:       if (style == STL_NM_LINK)
// TODO:          HelpStyleInfo[STYLE_INDEX(style)].color =
// TODO:             AllocateColor(parent, GetPrefHelpLinkColor(), &r, &g, &b);
// TODO:    }
// TODO: }
// TODO: 
// TODO: static void adaptNavigationButtons(int topic)
// TODO: {
// TODO:    Fl_Widget* btn;
// TODO: 
// TODO:    if (HelpWindows[topic] == NULL)
// TODO:       return; /* Shouldn't happen */
// TODO: 
// TODO:    btn=XtNameToWidget(HelpWindows[topic], "helpForm.prevTopic");
// TODO:    if (btn)
// TODO:    {
// TODO:       if (topic > 0)
// TODO:          NeSetSensitive(btn, true);
// TODO:       else
// TODO:          NeSetSensitive(btn, false);
// TODO:    }
// TODO: 
// TODO:    btn=XtNameToWidget(HelpWindows[topic], "helpForm.nextTopic");
// TODO:    if (btn)
// TODO:    {
// TODO:       if (topic < (NUM_TOPICS - 1))
// TODO:          NeSetSensitive(btn, true);
// TODO:       else
// TODO:          NeSetSensitive(btn, false);
// TODO:    }
// TODO: 
// TODO:    btn=XtNameToWidget(HelpWindows[topic], "helpForm.histBack");
// TODO:    if (btn)
// TODO:    {
// TODO:       if (navHistBack[topic] != -1)
// TODO:          NeSetSensitive(btn, true);
// TODO:       else
// TODO:          NeSetSensitive(btn, false);
// TODO:    }
// TODO: 
// TODO:    btn=XtNameToWidget(HelpWindows[topic], "helpForm.histForw");
// TODO:    if (btn)
// TODO:    {
// TODO:       if (navHistForw[topic] != -1)
// TODO:          NeSetSensitive(btn, true);
// TODO:       else
// TODO:          NeSetSensitive(btn, false);
// TODO:    }
// TODO: 
// TODO: }
// TODO: 
// TODO: /*
// TODO: ** Put together stored help strings to create the text and optionally the style
// TODO: ** information for a given help topic.
// TODO: */
// TODO: static char* stitch(
// TODO: 
// TODO:    Fl_Widget*  parent,      /* used for dynamic font/color allocation */
// TODO:    char** string_list,  /* given help strings to stitch together */
// TODO:    char** styleMap      /* NULL, or a place to store help styles */
// TODO: )
// TODO: {
// TODO:    char*    cp;
// TODO:    char*    section, * sp;       /* resulting help text section            */
// TODO:    char*    styleData, * sdp;    /* resulting style data for text          */
// TODO:    char     style = STYLE_PLAIN; /* start off each section with this style */
// TODO:    int      total_size = 0;      /* help text section size                 */
// TODO:    char**   crnt_line;
// TODO: 
// TODO:    /*----------------------------------------------------
// TODO:    * How many characters are there going to be displayed?
// TODO:    *----------------------------------------------------*/
// TODO:    for (crnt_line = string_list; *crnt_line != NULL; crnt_line++)
// TODO:    {
// TODO:       for (cp = *crnt_line; *cp != EOS; cp++)
// TODO:       {
// TODO:          /*---------------------------------------------
// TODO:          * The help text has embedded style information
// TODO:          * consisting of the style marker and a single
// TODO:          * character style, for a total of 2 characters.
// TODO:          * This style information is not to be included
// TODO:          * in the character counting below.
// TODO:          *---------------------------------------------*/
// TODO:          if (*cp != STYLE_MARKER)
// TODO:          {
// TODO:             total_size++;
// TODO:          }
// TODO:          else
// TODO:          {
// TODO:             cp++;  /* skipping style marker, loop will handle style */
// TODO:          }
// TODO:       }
// TODO:    }
// TODO: 
// TODO:    /*--------------------------------------------------------
// TODO:    * Get the needed space, one area for the help text being
// TODO:    * stitched together, another for the styles to be applied.
// TODO:    *--------------------------------------------------------*/
// TODO:    sp  = section   = malloc__(total_size +1);
// TODO:    sdp = styleData = (styleMap) ? malloc__(total_size +1)  : NULL;
// TODO:    *sp = EOS;
// TODO: 
// TODO:    /*--------------------------------------------
// TODO:    * Fill in the newly acquired contiguous space
// TODO:    * with help text and style information.
// TODO:    *--------------------------------------------*/
// TODO:    for (crnt_line = string_list; *crnt_line != NULL; crnt_line++)
// TODO:    {
// TODO:       for (cp = *crnt_line; *cp != EOS; cp++)
// TODO:       {
// TODO:          if (*cp == STYLE_MARKER)
// TODO:          {
// TODO:             style = *(++cp);
// TODO:             loadFontsAndColors(parent, style);
// TODO:          }
// TODO:          else
// TODO:          {
// TODO:             *(sp++)  = *cp;
// TODO: 
// TODO:             /* Beware of possible EBCDIC coding! Use the mapping table. */
// TODO:             if (styleMap)
// TODO:                *(sdp++) = AlphabetToAsciiTable[(unsigned char)style];
// TODO:          }
// TODO:       }
// TODO:    }
// TODO: 
// TODO:    *sp = EOS;
// TODO: 
// TODO:    /*-----------------------------------------
// TODO:    * Only deal with style map, when available.
// TODO:    *-----------------------------------------*/
// TODO:    if (styleMap)
// TODO:    {
// TODO:       *styleMap = styleData;
// TODO:       *sdp      = EOS;
// TODO:    }
// TODO: 
// TODO:    return section;
// TODO: }

/*
** Display help for subject "topic".  "parent" is a widget over which the help
** dialog may be posted.  Help dialogs are preserved when popped down by the
** user, and may appear posted over a previous parent, regardless of the parent
** argument.
*/
void Help(enum HelpTopic topic)
{
   TRACE();
// TODO:    if (HelpWindows[topic] != NULL)
// TODO:       RaiseShellWindow(HelpWindows[topic], true);
// TODO:    else
// TODO:       HelpWindows[topic] = createHelpPanel(topic);
// TODO:    adaptNavigationButtons(topic);
}


// TODO: /* Setup Window/Icon title for the help window. */
// TODO: static void setHelpWinTitle(Fl_Widget* win, enum HelpTopic topic)
// TODO: {
// TODO:    char* buf, *topStr=HelpTitles[topic];
// TODO: 
// TODO:    buf=(char*)malloc__(strlen(topStr) + 24);
// TODO:    topic = topic + 1;
// TODO: 
// TODO:    sprintf(buf, "NEdit Help (%d)", (int)topic);
// TODO:    XtVaSetValues(win, XmNiconName, buf, NULL);
// TODO: 
// TODO:    sprintf(buf, "NEdit Help: %s (%d)", topStr, (int)topic);
// TODO:    XtVaSetValues(win, XmNtitle, buf, NULL);
// TODO: 
// TODO:    free__(buf);
// TODO: }
// TODO: 
// TODO: /*
// TODO: ** Create a new help window displaying a given subject, "topic"
// TODO: **
// TODO: ** Important hint: If this widget is restructured or the name of the text
// TODO: ** subwidget is changed don't forget to adapt the default translations of the
// TODO: ** help text. They are located in nedit.c, look for
// TODO: **   static char *fallbackResources
// TODO: **   (currently:  nedit.helpForm.sw.helpText*translations...)
// TODO: */
// TODO: static Fl_Widget* createHelpPanel(enum HelpTopic topic)
// TODO: {
// TODO:    Arg al[50];
// TODO:    int ac;
// TODO:    Fl_Widget* appShell, btn, closeBtn, form, btnFW;
// TODO:    Fl_Widget* sw, hScrollBar, vScrollBar;
// TODO:    NeString st1;
// TODO:    char* helpText  = NULL;
// TODO:    char* styleData = NULL;
// TODO: 
// TODO:    ac = 0;
// TODO:    XtSetArg(al[ac], XmNdeleteResponse, XmDO_NOTHING);
// TODO:    ac++;
// TODO:    appShell = CreateWidget(TheAppShell, "help",
// TODO:                            topLevelShellWidgetClass, al, ac);
// TODO:    AddSmallIcon(appShell);
// TODO:    /* With openmotif 2.1.30, a crash may occur when the text widget of the
// TODO:       help window is (slowly) resized to a zero width. By imposing a
// TODO:       minimum _window_ width, we can work around this problem. The minimum
// TODO:       width should be larger than the width of the scrollbar. 50 is probably
// TODO:       a safe value; this leaves room for a few characters */
// TODO:    XtVaSetValues(appShell, XtNminWidth, 50, NULL);
// TODO:    form = XtVaCreateManagedWidget("helpForm", xmFormWidgetClass, appShell,
// TODO:                                   NULL);
// TODO:    XtVaSetValues(form, XmNshadowThickness, 0, NULL);
// TODO: 
// TODO:    /* Create the bottom row of buttons */
// TODO:    btn = XtVaCreateManagedWidget("find", xmPushButtonWidgetClass, form,
// TODO:                                  XmNlabelString, st1=NeNewString("Find..."),
// TODO:                                  XmNmnemonic, 'F',
// TODO:                                  XmNbottomAttachment, XmATTACH_FORM,
// TODO:                                  XmNleftAttachment, XmATTACH_POSITION,
// TODO:                                  XmNleftPosition, 3,
// TODO:                                  XmNrightAttachment, XmATTACH_POSITION,
// TODO:                                  XmNrightPosition, 25,
// TODO:                                  NULL);
// TODO:    XtAddCallback(btn, XmNactivateCallback, searchHelpCB, appShell);
// TODO:    NeStringFree(st1);
// TODO: 
// TODO:    btn = XtVaCreateManagedWidget("findAgain", xmPushButtonWidgetClass, form,
// TODO:                                  XmNlabelString, st1=NeNewString("Find Again"),
// TODO:                                  XmNmnemonic, 'A',
// TODO:                                  XmNbottomAttachment, XmATTACH_FORM,
// TODO:                                  XmNleftAttachment, XmATTACH_POSITION,
// TODO:                                  XmNleftPosition, 27,
// TODO:                                  XmNrightAttachment, XmATTACH_POSITION,
// TODO:                                  XmNrightPosition, 49,
// TODO:                                  NULL);
// TODO:    XtAddCallback(btn, XmNactivateCallback, searchHelpAgainCB, appShell);
// TODO:    NeStringFree(st1);
// TODO: 
// TODO:    btn = XtVaCreateManagedWidget("print", xmPushButtonWidgetClass, form,
// TODO:                                  XmNlabelString, st1=NeNewString("Print..."),
// TODO:                                  XmNmnemonic, 'P',
// TODO:                                  XmNbottomAttachment, XmATTACH_FORM,
// TODO:                                  XmNleftAttachment, XmATTACH_POSITION,
// TODO:                                  XmNleftPosition, 51,
// TODO:                                  XmNrightAttachment, XmATTACH_POSITION,
// TODO:                                  XmNrightPosition, 73,
// TODO:                                  NULL);
// TODO:    XtAddCallback(btn, XmNactivateCallback, printCB, appShell);
// TODO:    NeStringFree(st1);
// TODO: 
// TODO:    closeBtn = XtVaCreateManagedWidget("close",
// TODO:                                       xmPushButtonWidgetClass, form,
// TODO:                                       XmNlabelString, st1=NeNewString("Close"),
// TODO:                                       XmNbottomAttachment, XmATTACH_FORM,
// TODO:                                       XmNleftAttachment, XmATTACH_POSITION,
// TODO:                                       XmNleftPosition, 75,
// TODO:                                       XmNrightAttachment, XmATTACH_POSITION,
// TODO:                                       XmNrightPosition, 97,
// TODO:                                       NULL);
// TODO:    XtAddCallback(closeBtn, XmNactivateCallback, closeCB, appShell);
// TODO:    NeStringFree(st1);
// TODO: 
// TODO:    /* Create the next row of buttons (for navigation) */
// TODO:    btn = XtVaCreateManagedWidget("prevTopic", xmPushButtonWidgetClass, form,
// TODO:                                  XmNlabelString, st1=NeNewString("<< Browse"),
// TODO:                                  XmNmnemonic, 'o',
// TODO:                                  XmNbottomAttachment, XmATTACH_WIDGET,
// TODO:                                  XmNbottomWidget, closeBtn,
// TODO:                                  XmNleftAttachment, XmATTACH_POSITION,
// TODO:                                  XmNleftPosition, 51,
// TODO:                                  XmNrightAttachment, XmATTACH_POSITION,
// TODO:                                  XmNrightPosition, 73,
// TODO:                                  NULL);
// TODO:    XtAddCallback(btn, XmNactivateCallback, prevTopicCB, appShell);
// TODO:    NeStringFree(st1);
// TODO: 
// TODO:    btn = XtVaCreateManagedWidget("nextTopic", xmPushButtonWidgetClass, form,
// TODO:                                  XmNlabelString, st1=NeNewString("Browse >>"),
// TODO:                                  XmNmnemonic, 'e',
// TODO:                                  XmNbottomAttachment, XmATTACH_WIDGET,
// TODO:                                  XmNbottomWidget, closeBtn,
// TODO:                                  XmNleftAttachment, XmATTACH_POSITION,
// TODO:                                  XmNleftPosition, 75,
// TODO:                                  XmNrightAttachment, XmATTACH_POSITION,
// TODO:                                  XmNrightPosition, 97,
// TODO:                                  NULL);
// TODO:    XtAddCallback(btn, XmNactivateCallback, nextTopicCB, appShell);
// TODO:    NeStringFree(st1);
// TODO: 
// TODO:    btn = XtVaCreateManagedWidget("histBack", xmPushButtonWidgetClass, form,
// TODO:                                  XmNlabelString, st1=NeNewString("Back"),
// TODO:                                  XmNmnemonic, 'B',
// TODO:                                  XmNbottomAttachment, XmATTACH_WIDGET,
// TODO:                                  XmNbottomWidget, closeBtn,
// TODO:                                  XmNleftAttachment, XmATTACH_POSITION,
// TODO:                                  XmNleftPosition, 3,
// TODO:                                  XmNrightAttachment, XmATTACH_POSITION,
// TODO:                                  XmNrightPosition, 25,
// TODO:                                  NULL);
// TODO:    XtAddCallback(btn, XmNactivateCallback, bwHistoryCB, appShell);
// TODO:    NeStringFree(st1);
// TODO: 
// TODO:    btnFW = XtVaCreateManagedWidget("histForw", xmPushButtonWidgetClass, form,
// TODO:                                    XmNlabelString, st1=NeNewString("Forward"),
// TODO:                                    XmNmnemonic, 'w',
// TODO:                                    XmNbottomAttachment, XmATTACH_WIDGET,
// TODO:                                    XmNbottomWidget, closeBtn,
// TODO:                                    XmNleftAttachment, XmATTACH_POSITION,
// TODO:                                    XmNleftPosition, 27,
// TODO:                                    XmNrightAttachment, XmATTACH_POSITION,
// TODO:                                    XmNrightPosition, 49,
// TODO:                                    NULL);
// TODO:    XtAddCallback(btnFW, XmNactivateCallback, fwHistoryCB, appShell);
// TODO:    NeStringFree(st1);
// TODO: 
// TODO:    /* Create a text widget inside of a scrolled window widget */
// TODO:    sw = XtVaCreateManagedWidget("sw", xmScrolledWindowWidgetClass, form,
// TODO:                                 XmNshadowThickness, 2,
// TODO:                                 XmNtopAttachment, XmATTACH_FORM,
// TODO:                                 XmNleftAttachment, XmATTACH_FORM,
// TODO:                                 XmNrightAttachment, XmATTACH_FORM,
// TODO:                                 XmNbottomAttachment, XmATTACH_WIDGET,
// TODO:                                 XmNbottomWidget, btnFW,
// TODO:                                 NULL);
// TODO:    hScrollBar = XtVaCreateManagedWidget("hScrollBar",
// TODO:                                         xmScrollBarWidgetClass, sw,
// TODO:                                         XmNorientation, XmHORIZONTAL,
// TODO:                                         XmNrepeatDelay, 10,
// TODO:                                         NULL);
// TODO:    vScrollBar = XtVaCreateManagedWidget("vScrollBar",
// TODO:                                         xmScrollBarWidgetClass, sw,
// TODO:                                         XmNorientation, XmVERTICAL,
// TODO:                                         XmNrepeatDelay, 10,
// TODO:                                         NULL);
// TODO:    /* Make sure the fixed size help font is loaded, such that we can base
// TODO:       our text widget size calculation on it. */
// TODO:    loadFontsAndColors(sw, 'A');
// TODO:    HelpTextPanes[topic] = XtVaCreateManagedWidget("helpText",
// TODO:                           textWidgetClass, sw,
// TODO:                           textNfont, HelpStyleInfo[0].font, /* MUST correspond to 'A' above */
// TODO:                           textNrows, 30,
// TODO:                           textNcolumns, 65,
// TODO:                           textNbacklightCharTypes, NULL,
// TODO:                           textNhScrollBar, hScrollBar,
// TODO:                           textNvScrollBar, vScrollBar,
// TODO:                           textNreadOnly, true,
// TODO:                           textNcontinuousWrap, true,
// TODO:                           textNautoShowInsertPos, true,
// TODO:                           NULL);
// TODO:    XtVaSetValues(sw, XmNworkWindow, HelpTextPanes[topic],
// TODO:                  XmNhorizontalScrollBar, hScrollBar,
// TODO:                  XmNverticalScrollBar, vScrollBar,
// TODO:                  NULL);
// TODO: 
// TODO:    /* Initialize help style information, if it hasn't already been init'd */
// TODO:    initHelpStyles(HelpTextPanes[topic]);
// TODO: 
// TODO:    /* Put together the text to display and separate it into parallel text
// TODO:       and style data for display by the widget */
// TODO:    helpText = stitch(HelpTextPanes[topic], HelpText[topic], &styleData);
// TODO: 
// TODO:    /* Stuff the text into the widget's text buffer */
// TODO:    BufSetAll(TextGetBuffer(HelpTextPanes[topic]) , helpText);
// TODO:    XtFree(helpText);
// TODO: 
// TODO:    /* Create a style buffer for the text widget and fill it with the style
// TODO:       data which was generated along with the text content */
// TODO:    HelpStyleBuffers[topic] = BufCreate();
// TODO:    BufSetAll(HelpStyleBuffers[topic], styleData);
// TODO:    XtFree(styleData);
// TODO:    TextDAttachHighlightData(((TextWidget)HelpTextPanes[topic])->text.textD,
// TODO:                             HelpStyleBuffers[topic], HelpStyleInfo, N_STYLES, '\0', NULL, NULL);
// TODO: 
// TODO:    /* This shouldn't be necessary (what's wrong in text.c?) */
// TODO:    HandleXSelections(HelpTextPanes[topic]);
// TODO: 
// TODO:    /* Process dialog mnemonic keys */
// TODO:    AddDialogMnemonicHandler(form, FALSE);
// TODO: 
// TODO:    /* Set the default button */
// TODO:    XtVaSetValues(form, XmNdefaultButton, closeBtn, NULL);
// TODO:    XtVaSetValues(form, XmNcancelButton, closeBtn, NULL);
// TODO: 
// TODO:    /* realize all of the widgets in the new window */
// TODO:    RealizeWithoutForcingPosition(appShell);
// TODO: 
// TODO:    /* Give the text pane the initial focus */
// TODO:    XmProcessTraversal(HelpTextPanes[topic], XmTRAVERSE_CURRENT);
// TODO: 
// TODO:    /* Make close command in window menu gracefully prompt for close */
// TODO:    AddMotifCloseCallback(appShell, (XtCallbackProc)closeCB, appShell);
// TODO: 
// TODO:    /* Initialize navigation information, if it hasn't already been init'd */
// TODO:    initNavigationHistory();
// TODO: 
// TODO:    /* Set the window title */
// TODO:    setHelpWinTitle(appShell, topic);
// TODO: 
// TODO: 
// TODO: #ifdef EDITRES
// TODO:    XtAddEventHandler(appShell, (EventMask)0, true,
// TODO:                      (XtEventHandler)_XEditResCheckMessages, NULL);
// TODO: #endif /* EDITRES */
// TODO: 
// TODO:    return appShell;
// TODO: }
// TODO: 
// TODO: static void changeTopicOrRaise(int existingTopic, int newTopic)
// TODO: {
// TODO:    if (HelpWindows[newTopic] == NULL)
// TODO:    {
// TODO:       changeWindowTopic(existingTopic, (enum HelpTopic) newTopic);
// TODO:       adaptNavigationButtons(newTopic);
// TODO:    }
// TODO:    else
// TODO:    {
// TODO:       RaiseShellWindow(HelpWindows[newTopic], true);
// TODO:       adaptNavigationButtons(existingTopic);
// TODO:       adaptNavigationButtons(newTopic);
// TODO:    }
// TODO: 
// TODO: }
// TODO: 
// TODO: /*
// TODO: ** Callbacks for window controls
// TODO: */
// TODO: static void closeCB(Fl_Widget* w, XtPointer clientData, XtPointer callData)
// TODO: {
// TODO:    int topic;
// TODO: 
// TODO:    if ((topic = findTopicFromShellWidget((Fl_Widget*)clientData)) == -1)
// TODO:       return;
// TODO: 
// TODO:    /* I don't understand the mechanism by which this can be called with
// TODO:       HelpWindows[topic] as NULL, but it has happened */
// TODO:    XtDestroyWidget(HelpWindows[topic]);
// TODO:    HelpWindows[topic] = NULL;
// TODO:    if (HelpStyleBuffers[topic] != NULL)
// TODO:    {
// TODO:       BufFree(HelpStyleBuffers[topic]);
// TODO:       HelpStyleBuffers[topic] = NULL;
// TODO:    }
// TODO: }
// TODO: 
// TODO: static void prevTopicCB(Fl_Widget* w, XtPointer clientData, XtPointer callData)
// TODO: {
// TODO:    int topic;
// TODO: 
// TODO:    if ((topic = findTopicFromShellWidget((Fl_Widget*)clientData)) == -1)
// TODO:       return; /* shouldn't happen */
// TODO: 
// TODO:    topic--;
// TODO:    if (topic >= 0)
// TODO:       changeTopicOrRaise(topic+1, topic);
// TODO: }
// TODO: 
// TODO: static void nextTopicCB(Fl_Widget* w, XtPointer clientData, XtPointer callData)
// TODO: {
// TODO:    int topic;
// TODO: 
// TODO:    if ((topic = findTopicFromShellWidget((Fl_Widget*)clientData)) == -1)
// TODO:       return; /* shouldn't happen */
// TODO: 
// TODO:    topic++;
// TODO:    if (topic < NUM_TOPICS)
// TODO:       changeTopicOrRaise(topic-1, topic);
// TODO: }
// TODO: 
// TODO: static void bwHistoryCB(Fl_Widget* w, XtPointer clientData, XtPointer callData)
// TODO: {
// TODO:    int topic, goTo;
// TODO: 
// TODO:    if ((topic = findTopicFromShellWidget((Fl_Widget*)clientData)) == -1)
// TODO:       return; /* shouldn't happen */
// TODO: 
// TODO:    goTo=navHistBack[topic];
// TODO:    if (goTo >= 0 && goTo < NUM_TOPICS)
// TODO:    {
// TODO:       navHistForw[goTo]=topic;
// TODO:       changeTopicOrRaise(topic, goTo);
// TODO:    }
// TODO: }
// TODO: 
// TODO: static void fwHistoryCB(Fl_Widget* w, XtPointer clientData, XtPointer callData)
// TODO: {
// TODO:    int topic, goTo;
// TODO: 
// TODO:    if ((topic = findTopicFromShellWidget((Fl_Widget*)clientData)) == -1)
// TODO:       return; /* shouldn't happen */
// TODO: 
// TODO:    goTo=navHistForw[topic];
// TODO:    if (goTo >= 0 && goTo < NUM_TOPICS)
// TODO:    {
// TODO:       navHistBack[goTo]=topic;
// TODO:       changeTopicOrRaise(topic, goTo);
// TODO:    }
// TODO: }
// TODO: 
// TODO: static void searchHelpCB(Fl_Widget* w, XtPointer clientData, XtPointer callData)
// TODO: {
// TODO:    char promptText[DF_MAX_PROMPT_LENGTH];
// TODO:    int response, topic;
// TODO:    static char** searchHistory = NULL;
// TODO:    static int nHistoryStrings = 0;
// TODO: 
// TODO:    if ((topic = findTopicFromShellWidget((Fl_Widget*)clientData)) == -1)
// TODO:       return; /* shouldn't happen */
// TODO:    SetDialogFPromptHistory(searchHistory, nHistoryStrings);
// TODO:    response = DialogF(DF_PROMPT, HelpWindows[topic], 3, "Find",
// TODO:                       "Search for:    (use up arrow key to recall previous)", promptText,
// TODO:                       "This Section", "All Sections", "Cancel");
// TODO:    if (response == 3)
// TODO:       return;
// TODO:    AddToHistoryList(promptText, &searchHistory, &nHistoryStrings);
// TODO:    searchHelpText(HelpWindows[topic], topic, promptText, response == 2, 0, 0);
// TODO: }
// TODO: 
// TODO: static void searchHelpAgainCB(Fl_Widget* w, XtPointer clientData,
// TODO:                               XtPointer callData)
// TODO: {
// TODO:    int topic;
// TODO: 
// TODO:    if ((topic = findTopicFromShellWidget((Fl_Widget*)clientData)) == -1)
// TODO:       return; /* shouldn't happen */
// TODO:    searchHelpText(HelpWindows[topic], topic, LastSearchString,
// TODO:                   LastSearchWasAllTopics, LastSearchPos, LastSearchTopic);
// TODO: }
// TODO: 
// TODO: static void printCB(Fl_Widget* w, XtPointer clientData, XtPointer callData)
// TODO: {
// TODO:    int topic, helpStringLen;
// TODO:    char* helpString;
// TODO: 
// TODO:    if ((topic = findTopicFromShellWidget((Fl_Widget*)clientData)) == -1)
// TODO:       return; /* shouldn't happen */
// TODO: 
// TODO:    helpString = TextGetWrapped(HelpTextPanes[topic], 0,
// TODO:                                TextGetBuffer(HelpTextPanes[topic])->length, &helpStringLen);
// TODO:    PrintString(helpString, helpStringLen, HelpWindows[topic],
// TODO:                HelpTitles[topic]);
// TODO:    XtFree(helpString);
// TODO: }
// TODO: 
// TODO: 
// TODO: /*
// TODO: ** Find the topic and text position within that topic targeted by a hyperlink
// TODO: ** with name "link_name". Returns true if the link was successfully interpreted.
// TODO: */
// TODO: static int is_known_link(char* link_name, int* topic, int* textPosition)
// TODO: {
// TODO:    Href* hypertext;
// TODO: 
// TODO:    /*------------------------------
// TODO:    * Direct topic links found here.
// TODO:    *------------------------------*/
// TODO:    for (*topic=0; HelpTitles[*topic] != NULL; (*topic)++)
// TODO:    {
// TODO:       if (strcmp(link_name, HelpTitles[*topic])  == 0)
// TODO:       {
// TODO:          *textPosition = 0;
// TODO:          return 1;
// TODO:       }
// TODO:    }
// TODO: 
// TODO:    /*------------------------------------
// TODO:    * Links internal to topics found here.
// TODO:    *------------------------------------*/
// TODO:    for (hypertext = &H_R[0]; hypertext != NULL; hypertext = hypertext->next)
// TODO:    {
// TODO:       if (strcmp(link_name, hypertext->source)  == 0)
// TODO:       {
// TODO:          *topic  = hypertext->topic;
// TODO:          *textPosition = hypertext->location;
// TODO:          return 1;
// TODO:       }
// TODO:    }
// TODO: 
// TODO:    return 0;
// TODO: }
// TODO: 
// TODO: /*
// TODO: ** Find the text of a hyperlink from a clicked character position somewhere
// TODO: ** within the hyperlink text, and display the help that it links to.
// TODO: */
// TODO: static void followHyperlink(int topic, int charPosition, int newWindow)
// TODO: {
// TODO:    textDisp* textD = ((TextWidget)HelpTextPanes[topic])->text.textD;
// TODO:    char* link_text;
// TODO:    int    link_topic;
// TODO:    int    link_pos;
// TODO:    int end        = charPosition;
// TODO:    int begin      = charPosition;
// TODO:    char whatStyle = BufGetCharacter(textD->styleBuffer, end);
// TODO: 
// TODO:    /*--------------------------------------------------
// TODO:    * Locate beginning and ending of current text style.
// TODO:    *--------------------------------------------------*/
// TODO:    while (whatStyle == BufGetCharacter(textD->styleBuffer, ++end));
// TODO:    while (whatStyle == BufGetCharacter(textD->styleBuffer, begin-1))  begin--;
// TODO: 
// TODO:    link_text = BufGetRange(textD->buffer, begin, end);
// TODO: 
// TODO:    if (is_known_link(link_text, &link_topic, &link_pos))
// TODO:    {
// TODO:       if (HelpWindows[link_topic] != NULL)
// TODO:       {
// TODO:          RaiseShellWindow(HelpWindows[link_topic], true);
// TODO:       }
// TODO:       else
// TODO:       {
// TODO:          if (newWindow)
// TODO:          {
// TODO:             HelpWindows[link_topic]
// TODO:                = createHelpPanel((enum HelpTopic) link_topic);
// TODO:          }
// TODO:          else
// TODO:          {
// TODO:             changeWindowTopic(topic, (enum HelpTopic) link_topic);
// TODO:          }
// TODO:       }
// TODO:       navHistBack[link_topic] = topic;
// TODO:       navHistForw[topic] = link_topic;
// TODO:       TextSetCursorPos(HelpTextPanes[link_topic], link_pos);
// TODO:       adaptNavigationButtons(link_topic);
// TODO:       adaptNavigationButtons(topic);
// TODO:    }
// TODO:    XtFree(link_text);
// TODO: }

static void helpFocusButtonsAP(Fl_Widget* w, int event, const char** args, int* nArgs)
{
// TODO:    XmProcessTraversal(w, XmTRAVERSE_NEXT_TAB_GROUP);
}

/*
 * handler for help-button-action(<button-name>)
 * Calls the activate callback for the named button widget of the help text win.
 */
static void helpButtonActionAP(Fl_Widget* w, int event, const char** args, int* nArgs)
{
// TODO:    char buf[80];
// TODO:    int topic;
// TODO:    Fl_Widget* btn;
// TODO: 
// TODO:    if (*nArgs != 1)
// TODO:    {
// TODO:       fprintf(stderr, "help-button-action: requires exactly one argument.\n");
// TODO:       return;
// TODO:    }
// TODO: 
// TODO:    /* Find the topic being displayed by this widget */
// TODO:    for (topic = 0; topic < NUM_TOPICS; topic++)
// TODO:       if (HelpTextPanes[topic] == w)
// TODO:          break;
// TODO: 
// TODO:    if (topic == NUM_TOPICS || HelpWindows[topic] == NULL)
// TODO:       return; /* Shouldn't happen */
// TODO: 
// TODO:    /* Compose the button widget name */
// TODO:    strcpy(&buf[0], "helpForm.");
// TODO:    if (strlen(args[0]) <= 70)
// TODO:    {
// TODO:       strcat(&buf[0], args[0]);
// TODO:    }
// TODO:    else
// TODO:    {
// TODO:       fprintf(stderr, "help-button-action: argument too long");
// TODO:       return;
// TODO:    }
// TODO: 
// TODO:    btn=XtNameToWidget(HelpWindows[topic], buf);
// TODO:    if (btn)
// TODO:    {
// TODO:       XtCallCallbacks(btn, XmNactivateCallback, HelpWindows[topic]);
// TODO:    }
// TODO:    else
// TODO:    {
// TODO:       fprintf(stderr, "help-button-action: invalid argument: %s\n", args[0]);
// TODO:    }
}

/*
 * Handler for action help-hyperlink()
 * Arguments: none - init: record event position
 *            "current": if clicked on a link, follow link in same window
 *            "new":     if clicked on a link, follow link in new window
 *
 * With the 1st argument "current" or "new" this action can have two additional
 * arguments. These arguments must be valid names of XmText actions.
 * In this case, the action named in argument #2 is called if the action
 * help-hyperlink is about to follow the hyperlink. The Action in argument #3
 * is called if no hyperlink has been recognized at the current event position.
 */
static void helpHyperlinkAP(Fl_Widget* w, int event, const char** args, int* nArgs)
{
// TODO:    XButtonEvent* e = (XButtonEvent*)event;
// TODO:    int topic;
// TODO:    textDisp* textD = ((TextWidget)w)->text.textD;
// TODO:    int clickedPos, newWin;
// TODO:    static int pressX=0, pressY=0;
// TODO: 
// TODO:    /* called without arguments we just record coordinates */
// TODO:    if (*nArgs == 0)
// TODO:    {
// TODO:       pressX = e->x;
// TODO:       pressY = e->y;
// TODO:       return;
// TODO:    }
// TODO: 
// TODO:    newWin = !strcmp(args[0], "new");
// TODO: 
// TODO:    if (!newWin && strcmp(args[0], "current"))
// TODO:    {
// TODO:       fprintf(stderr, "help-hyperlink: Unrecognized argument %s\n", args[0]);
// TODO:       return;
// TODO:    }
// TODO: 
// TODO:    /*
// TODO:     * If for any reason (pointer moved - drag!, no hyperlink found)
// TODO:     * this action can't follow a hyperlink then execute the the action
// TODO:     * named in arg #3 (if provided)
// TODO:     */
// TODO:    if (abs(pressX - e->x) > CLICK_THRESHOLD
// TODO:          || abs(pressY - e->y) > CLICK_THRESHOLD)
// TODO:    {
// TODO:       if (*nArgs == 3)
// TODO:          XtCallActionProc(w, args[2], event, NULL, 0);
// TODO:       return;
// TODO:    }
// TODO: 
// TODO:    clickedPos = TextDXYToCharPos(textD, e->x, e->y);
// TODO:    /* Beware of possible EBCDIC coding! Use the mapping table. */
// TODO:    if (BufGetCharacter(textD->styleBuffer, clickedPos) !=
// TODO:          (char)AlphabetToAsciiTable[(unsigned char)STL_NM_LINK])
// TODO:    {
// TODO:       if (*nArgs == 3)
// TODO:          XtCallActionProc(w, args[2], event, NULL, 0);
// TODO:       return;
// TODO:    }
// TODO: 
// TODO:    /* Find the topic being displayed by this widget */
// TODO:    for (topic = 0; topic < NUM_TOPICS; topic++)
// TODO:       if (HelpTextPanes[topic] == w)
// TODO:          break;
// TODO: 
// TODO:    if (topic == NUM_TOPICS)
// TODO:    {
// TODO:       /* If we get here someone must have bound help-hyperlink to a non-help
// TODO:        * text widget (!) Or some other really strange thing happened.
// TODO:        */
// TODO:       if (*nArgs == 3)
// TODO:          XtCallActionProc(w, args[2], event, NULL, 0);
// TODO:       return;
// TODO:    }
// TODO: 
// TODO:    /* If the action help-hyperlink had 3 arguments execute the action
// TODO:     * named in arg #2 before really following the link.
// TODO:     */
// TODO:    if (*nArgs == 3)
// TODO:       XtCallActionProc(w, args[1], event, NULL, 0);
// TODO: 
// TODO:    followHyperlink(topic, clickedPos, newWin);
}

// Install the action for following hyperlinks in the help window
void InstallHelpLinkActions(Ne_AppContext& context)
{
   static XtActionsRec Actions[] =
   {
      {"help-hyperlink", helpHyperlinkAP},
      {"help-focus-buttons", helpFocusButtonsAP},
      {"help-button-action", helpButtonActionAP}
   };

   NeAppAddActions(context, Actions, ARRAY_SIZE(Actions));
}

// TODO: /*
// TODO: ** Search the help text.  If allSections is true, searches all of the help
// TODO: ** text, otherwise searches only in parentTopic.
// TODO: */
// TODO: static void searchHelpText(Fl_Widget* parent, int parentTopic,
// TODO:                            const char* searchFor, int allSections, int startPos, int startTopic)
// TODO: {
// TODO:    int topic, beginMatch, endMatch;
// TODO:    int found = false;
// TODO:    char* helpText  = NULL;
// TODO: 
// TODO:    /* Search for the string */
// TODO:    for (topic=startTopic; topic<NUM_TOPICS; topic++)
// TODO:    {
// TODO:       if (!allSections && topic != parentTopic)
// TODO:          continue;
// TODO:       helpText = stitch(parent, HelpText[topic], NULL);
// TODO: 
// TODO:       if (SearchString(helpText, searchFor, SEARCH_FORWARD, SEARCH_LITERAL,
// TODO:                        false, topic == startTopic ? startPos : 0, &beginMatch,
// TODO:                        &endMatch, NULL, NULL, GetPrefDelimiters()))
// TODO:       {
// TODO:          found = true;
// TODO:          XtFree(helpText);
// TODO:          break;
// TODO:       }
// TODO:       XtFree(helpText);
// TODO:    }
// TODO: 
// TODO:    if (!found)
// TODO:    {
// TODO:       if (startPos != 0 || (allSections && startTopic != 0))
// TODO:       {
// TODO:          /* Wrap search */
// TODO:          searchHelpText(parent, parentTopic, searchFor, allSections, 0, 0);
// TODO:          return;
// TODO:       }
// TODO:       DialogF(DF_INF, parent, 1, "const char* Not Found", "const char* Not Found", "OK");
// TODO:       return;
// TODO:    }
// TODO: 
// TODO:    /* update navigation history */
// TODO:    if (parentTopic != topic)
// TODO:    {
// TODO:       navHistForw[parentTopic]= topic;
// TODO:       navHistBack[topic]= parentTopic;
// TODO:    }
// TODO: 
// TODO:    /* If the appropriate window is already up, bring it to the top, if not,
// TODO:       make the parent window become this topic */
// TODO:    changeTopicOrRaise(parentTopic, topic);
// TODO:    BufSelect(TextGetBuffer(HelpTextPanes[topic]), beginMatch, endMatch);
// TODO:    TextSetCursorPos(HelpTextPanes[topic], endMatch);
// TODO: 
// TODO:    /* Save the search information for search-again */
// TODO:    strcpy(LastSearchString, searchFor);
// TODO:    LastSearchTopic = topic;
// TODO:    LastSearchPos = endMatch;
// TODO:    LastSearchWasAllTopics = allSections;
// TODO: }
// TODO: 
// TODO: /*
// TODO: ** Change a help window to display a new topic.  (Help window data is stored
// TODO: ** and indexed by topic so if a given topic is already displayed or has been
// TODO: ** positioned by the user, it can be found and popped back up in the same
// TODO: ** place.)  To change the topic displayed, the stored data has to be relocated.
// TODO: */
// TODO: static void changeWindowTopic(int existingTopic, enum HelpTopic newTopic)
// TODO: {
// TODO:    char* helpText, *styleData;
// TODO: 
// TODO:    /* Relocate the window/widget/buffer information */
// TODO:    if (newTopic != existingTopic)
// TODO:    {
// TODO:       HelpWindows[newTopic] = HelpWindows[existingTopic];
// TODO:       HelpWindows[existingTopic] = NULL;
// TODO:       HelpStyleBuffers[newTopic] = HelpStyleBuffers[existingTopic];
// TODO:       HelpStyleBuffers[existingTopic] = NULL;
// TODO:       HelpTextPanes[newTopic] = HelpTextPanes[existingTopic];
// TODO:       HelpTextPanes[existingTopic] = NULL;
// TODO:       setHelpWinTitle(HelpWindows[newTopic], newTopic);
// TODO:    }
// TODO: 
// TODO:    /* Set the existing text widget to display the new text.  Because it's
// TODO:       highlighted, we have to turn off highlighting before changing the
// TODO:       displayed text to prevent the text widget from trying to apply the
// TODO:       old, mismatched, highlighting to the new text */
// TODO:    helpText = stitch(HelpTextPanes[newTopic], HelpText[newTopic], &styleData);
// TODO:    TextDAttachHighlightData(((TextWidget)HelpTextPanes[newTopic])->text.textD,
// TODO:                             NULL, NULL, 0, '\0', NULL, NULL);
// TODO:    BufSetAll(TextGetBuffer(HelpTextPanes[newTopic]), helpText);
// TODO:    XtFree(helpText);
// TODO:    BufSetAll(HelpStyleBuffers[newTopic], styleData);
// TODO:    XtFree(styleData);
// TODO:    TextDAttachHighlightData(((TextWidget)HelpTextPanes[newTopic])->text.textD,
// TODO:                             HelpStyleBuffers[newTopic], HelpStyleInfo, N_STYLES, '\0', NULL,
// TODO:                             NULL);
// TODO: }
// TODO: 
// TODO: static int findTopicFromShellWidget(Fl_Widget* shellWidget)
// TODO: {
// TODO:    int i;
// TODO: 
// TODO:    for (i=0; i<NUM_TOPICS; i++)
// TODO:       if (shellWidget == HelpWindows[i])
// TODO:          return i;
// TODO:    return -1;
// TODO: }
// TODO: 
// TODO: static void initNavigationHistory()
// TODO: {
// TODO:    static int doInitNavigationHistory = true;
// TODO:    int i;
// TODO: 
// TODO:    if (doInitNavigationHistory)
// TODO:    {
// TODO:       for (i=0; i<NUM_TOPICS; i++)
// TODO:          navHistBack[i] = navHistForw[i] = -1;
// TODO: 
// TODO:       doInitNavigationHistory = false;
// TODO:    }
// TODO: }
// TODO: 
// TODO: #if XmVersion == 2000
// TODO: /* amai: This function may be called before the Motif part
// TODO:          is being initialized. The following, public interface
// TODO:          is known to initialize at least xmUseVersion.
// TODO:          That interface is declared in <Xm/Xm.h> in Motif 1.2 only.
// TODO:          As for Motif 2.1 we don't need this call anymore.
// TODO:          This also holds for the Motif 2.1 version of LessTif
// TODO:          releases > 0.93.0. */
// TODO: extern void XmRegisterConverters();
// TODO: #endif
// TODO: 

// Print version info to stdout
void PrintVersion()
{
   const char* text = getBuildInfo();
   puts(text);
}
